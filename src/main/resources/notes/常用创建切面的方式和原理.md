### Advice类型

根据切面切入的位置，有如下5种通知：

* @Before：前置通知，目标方法执行之前执行
*  @After：后置通知，目标方法执行之后执行
* @AfterReturning：返回通知，方法正常返回之前执行
* @AfterThrowing：异常通知，方法异常返回之前执行
* @Around：环绕通知，控制权交给切面，可以实现上述4种所有的功能

```
// 前置通知执行
...Before...
Object ret = null;
try {
	// 目标方法执行
	ret = method.invoke();
} catch (Exception e) {
	// 方法异常返回之前执行
	...AfterThrowing...
} finally {
	// 后置通知
	...After...
}

// 方法返回之前执行
...AfterReturning...
return ret;
```



执行顺序：Around->Before->After->AfterReturning/AfterThrowing，一般情况下只需指定环绕通知或其他几个具体通知，不会同时使用。

参考：org.springframework.aop.aspectj.annotation.ReflectiveAspectJAdvisorFactory

```java
public class ReflectiveAspectJAdvisorFactory extends AbstractAspectJAdvisorFactory implements Serializable {

	private static final Comparator<Method> METHOD_COMPARATOR;

	static {
		Comparator<Method> adviceKindComparator = new ConvertingComparator<>(
				new InstanceComparator<>(
						// 切面执行顺序
						Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class),
				(Converter<Method, Annotation>) method -> {
					AspectJAnnotation<?> annotation =
						AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(method);
					return (annotation != null ? annotation.getAnnotation() : null);
				});
		Comparator<Method> methodNameComparator = new ConvertingComparator<>(Method::getName);
		METHOD_COMPARATOR = adviceKindComparator.thenComparing(methodNameComparator);
	}
	...
}
```



### 自行编写切面



#### PointCut表达式



* 格式：

  * **execution:**   匹配方法，Spring AOP 最基本的切点表达式。其格式为：

    ```java
    execution([访问权限符] 返回值 全限定类名.方法名(方法参数列表))，其中【访问权限符】为可选项，且值只能为public
    ```

  * **within: ** 匹配类型，其格式为：

    ```
     @Pointcut("within(cc.lzy.spring.aop.service.*Impl)")  匹配service包下已Imple结尾的类，
     ！！！注意当指定特定类时，必须指定实现类，指定接口不管用。
    ```

  * **this：** 获取当前对象，即代理对象proxy，和其他切面表达式联合使用

  *  **target:** 获取目标对象，即被代理对象，和其他切面表达式联合使用

    ```
     @Around("pintCut() && this(proxy) && target(target)")
    ```

  * **@within:** 匹配标注了指定注解的类的所有公共方法，注解的RetentionPolicy必须为Class及以上。

    ```
    @Pointcut("@within(cc.lzy.spring.aop.annotation.ShopLogInterceptor)")
    ```

  * **@annotation:** 匹配指定注解标注的方法，必须打在实现类的方法上，打在接口或接口方法或实现类上均无效，需要根据连接点Context来判断是否匹配，所以效率相对不高。

    ```
    @Pointcut("@annotation(cc.lzy.spring.aop.annotation.ShopLogInterceptor)")
    ```

  * **bean:**  Spring自定义切面表达式，非标准AspectJ表达式，只能用于Spring。

    ```
    @Pointcut("within(cc.lzy.spring.aop.service.*) && bean(*Impl)")
    ```

  *  **@target：** 匹配当前执行对象所属类标注了指定注解的类的所有公共方法，与 @within  的不同点在于，@target是需要注解保留到运行时，注解的RetentionPolicy必须为Runtime，所以效率不高，实际生产环境没用过。

     ```java
     @Pointcut("@target(cc.lzy.spring.aop.annotation.ShopLogInterceptor)")
     ```

  *  **@args:** 匹配运行时参数的Class标注有指定注解的方法，注解的RetentionPolicy必须为Runtime，实际生产环境没用过。

     ```
     @Pointcut("@args(cc.lzy.spring.aop.annotation.ShopLogInterceptor)")
     
     public interface ShopService {
         String delete(DeleteParam deleteParam);
     }
     
     @ShopLogInterceptor
     public class DeleteParam {
     }
     ```

     

* 特殊字符

  * *：匹配任意多个字符（用于返回值、全限定类名、方法名时）或任意一个参数类型（用于方法参数列表时） 

    ```java
    // 匹配任意datasource1包下的以DAO结尾的所有类的insert方法，方法参数个数为1个，类型不限
    execution(public void cc.lzy.spring.aop.dao.datasource1.*DAO.insert(*))
    ```

  * .. ：匹配任意多层路径（用于全限定类名时）或匹配任意多个 、任意类型参数（用于方法参数列表时）

    ```java
    // 匹配任意dao包及其子包下面所有以DAO结尾的类的所有方法
    execution(public void cc.lzy.spring.aop.dao..*DAO.*(..))
    ```

* 逻辑运算符: && || !

  ```
  execution(public void cc.lzy.spring.aop.dao.datasource1.*DAO.insert(*)) || 
  execution(public void cc.lzy.spring.aop.dao.datasource2.*DAO.insert(*))
  ```

*  最佳实践：切面表达式尽量精确，缩小匹配范围，良好的切面表达式应该总是以下格式：范围匹配表达式&&其他匹配表达式。

#### 注解

使用注解定义切面，有如下步骤：

* Step1. 开启包扫描：

  ```
  <!-- 开启包扫描 -->
  <context:component-scan base-package="cc.lzy.spring.aop"/>
  ```

* Step2. 声明自动为spring容器中那些配置@aspectJ切面的bean创建代理：

  ```
  <!-- 开启注解驱动AOP, 不开启没什么软用 -->
  <!-- 声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面 -->
  <aop:aspectj-autoproxy/>
  ```

* Step3. 编写切面：

```java
/**
 * 当有多个切面时，使用Order注解可以指定切面顺序，值越小优先级越高
 */
@Component
@Aspect
@Order(1)
public class ItemServiceLogAspect {

		// 抽取可重用的PointCut
		
    @Before("execution(public int cc.lzy.spring.aop.service.ItemService.*(..))")
    public void before() {
        System.out.println("...Before Item...");
    }

    @AfterReturning("execution(void cc.lzy.spring.aop.service.ItemService.*(..))")
    public void afterReturning() {
        System.out.println("...AfterReturning Item...");
    }

    @AfterThrowing("execution(void cc.lzy.spring.aop.service.ItemService.*(..))")
    public void afterThrowing() {
        System.out.println("...AfterThrowing Item...");
    }

    @After("execution(void cc.lzy.spring.aop.service.ItemService.*(..))")
    public void after() {
        System.out.println("...After Item...");
    }
}
```



```java
/**
  * 抽取可重用的PointCut示例
 */
@Component
@Aspect
@Order(2)
public class ItemServiceLogAspect {

    /**
     * 抽取可重用的PointCut
     */
    @Pointcut("execution(public * cc.lzy.spring.aop.service.ItemService.*(..))")
    public void myPointCut() {
    }

    /**
     * 引用PointCut
     */
    @Before("myPointCut()")
    public void before(JoinPoint joinPoint) {
        System.out.println(joinPoint.getSignature().getName() + "...Before Item..." + ", args:" + ", args:" + Arrays.toString(joinPoint.getArgs()));
    }

    /**
     * 引用PointCut，获取结果对象
     */
    @AfterReturning(value = "myPointCut()", returning = "result")
    public void afterReturning(JoinPoint joinPoint, Object result) {
        System.out.println(joinPoint.getSignature().getName() + "...AfterReturning Item..." + ", result=" + result);
    }

    /**
     * 引用PointCut，获取异常对象
     */
    @AfterThrowing(value = "myPointCut()", throwing = "th")
    public void afterThrowing(JoinPoint joinPoint, Throwable th) {
        System.out.println(joinPoint.getSignature().getName() + "...AfterThrowing Item..." + ", th" + th);
    }

    /**
     * 引用PointCut
     */
    @After("myPointCut()")
    private static int after(JoinPoint joinPoint) {
        System.out.println(joinPoint.getSignature().getName() + "...After Item...");
        return 10;
    }
}
```



```java
/**
 * Around 切面
 */
@Component
@Aspect
@Order(1)
public class ShopServiceAspect {
    

    // annotation, 注解必须标注在实现类上，标注在接口无效。ShopLogInterceptor需 RetentionPolicy.RUNTIME
    @Pointcut("@target(cc.lzy.spring.aop.annotation.ShopLogInterceptor)")
    public static void pintCut() {

    }

    // annotation, 注解必须标注在实现类上，标注在接口无效。
    //@Pointcut("@within(cc.lzy.spring.aop.annotation.ShopLogInterceptor)")
    //public static void pintCut() {
    //
    //}

    // annotation, 注解必须标注在实现类上的方法上，标注在接口、接口方法、实现类上均无效。
    //@Pointcut("@annotation(cc.lzy.spring.aop.annotation.ShopLogInterceptor)")
    //public static void pintCut() {
    //
    //}

    // bean , service包下的实现类
    //@Pointcut("within(cc.lzy.spring.aop.service.*) && bean(*Impl)")
    //public static void pintCut() {
    //
    //}

    // within
    //    @Pointcut("within(cc.lzy.spring.aop.service.ShopServiceImpl)")
    //    public static void pintCut() {
    //
    //    }

    // execution
    //    @Pointcut("execution(public * cc.lzy.spring.aop.service.ShopService.*(..))")
    //    public static void pintCut() {
    //
    //    }

    @Around("pintCut() && this(proxy) && target(target)")
    public void intercept(ProceedingJoinPoint pjp, Object proxy, Object target) {
        // 当前Bean，即代理对象
        System.out.println("proxy=" + proxy.getClass());

        // 目标Bean，即被代理对象
        System.out.println("target=" + target.getClass());

        Object[] args = pjp.getArgs();
        Object ret = null;
        try {
            // before
            System.out.println("before, args: " + Arrays.toString(args));
            // invoke
            ret = pjp.proceed();

            // invoke, 可以改写入参
            // args = new Object[] {"xxx-yyy-zzz"};
            // Object ret = pjp.proceed(args);
            // after returning

            System.out.println("after returning, result: " + ret);
        } catch (Throwable t) {
            // after throwing
            System.out.println("after throwing, t: " + t);
        } finally {
            System.out.println("after, args: " + Arrays.toString(args));
        }
      
      	return ret;
    }
}
```



#### XML

可以使用xml文件配置切面，步骤如下：

* step1. 将服务和切面配置为普通Bean

* step2. 配置切面

  ```
  <!-- 将Bean注册到容器 -->
  <bean id="mobileService" class="cc.lzy.spring.aop.service.MobileServiceImpl"/>
  <bean id="mobileServiceAspect" class="cc.lzy.spring.aop.xml.MobileServiceLogAspect"/>
  <!-- 切面配置，如果有多个切面同时切同一个对象，则已配置的先后顺序为准-->
  <aop:config>
      <aop:pointcut id="mobileServicePointCut" expression="execution(public * cc.lzy.spring.aop.service.MobileService.*(..))"/>
      <!-- 等价于@Aspect -->
      <aop:aspect ref="mobileServiceAspect" order="1">
          <!-- 前置和环绕，谁先执行，跟配置顺序有关，而采用注解方式的时候环绕优先-->
          <aop:around method="around" pointcut-ref="mobileServicePointCut"/>
          <!-- after即使配置在前，也是在before之后才执行-->
          <aop:after method="after" pointcut-ref="mobileServicePointCut"/>
          <aop:before method="before" pointcut="execution(public * cc.lzy.spring.aop.service.MobileService.*(..)) &amp;&amp; this(proxy) &amp;&amp; target(target)" />
          <aop:after-returning method="afterReturning" pointcut-ref="mobileServicePointCut" returning="ret"/>
          <aop:after-throwing method="afterThrowing" pointcut-ref="mobileServicePointCut" throwing="th"/>
      </aop:aspect>
  </aop:config>
  ```



#### 注解 VS  切面

注解切面比较简单，XML配置相对繁琐。但是XML配置的方式可以应用于任何类（比如二方包的类，源代码无法改动），注解做不到。

一般来讲，对于全局的重要切面，比如拦截所有RPC请求，打印摘要日志，一般使用XML的方式配置，切面集中配置到配置文件中，一目了然。对于只拦截指定服务的特殊切面，可以放到服务所在的包下面，采用注解的方式进行拦截。

当然，上述只作参考，重点在于了解二者的不同点 。实战时，还需具体场景具体分析，最佳实践是遵守所在团队的编码规范，大家风格保持一致，这样最便于维护和理解。




### 使用工具类辅助编写切面

#### 注解



#### XML





### Spring创建代理的方式



如果被代理对象所属类实现了接口，使用JDK动态代理生成代理类，否则使用CGLIB生成代理类。



```java
public class DefaultAopProxyFactory implements AopProxyFactory, Serializable {

	@Override
	public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
		if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {
			Class<?> targetClass = config.getTargetClass();
			if (targetClass == null) {
				throw new AopConfigException("TargetSource cannot determine target class: " +
						"Either an interface or a target is required for proxy creation.");
			}
      // 多层代理？？暂不清楚什么时候会走此分支
			if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
				return new JdkDynamicAopProxy(config);
			}
      // 否则使用CGLIB动态创建代理类
			return new ObjenesisCglibAopProxy(config);
		}
		else {
      // 实现了接口，则使用JDK动态代理，一般用户自定义的接口被代理时，会走到此分支
			return new JdkDynamicAopProxy(config);
		}
	}
  
	/**
	 * 是否没有用户提供的接口，即判断除了Spring自身默认注入的SpringProxy接口外，是否实现了用户自定义的接口
	 
	 * Determine whether the supplied {@link AdvisedSupport} has only the
	 * {@link org.springframework.aop.SpringProxy} interface specified
	 * (or no proxy interfaces specified at all).
	 */
	private boolean hasNoUserSuppliedProxyInterfaces(AdvisedSupport config) {
		Class<?>[] ifcs = config.getProxiedInterfaces();
		return (ifcs.length == 0 || (ifcs.length == 1 && SpringProxy.class.isAssignableFrom(ifcs[0])));
	}
}
```



### 动态代理

对于实现了接口的类，默认使用JDK动态代理来创建代理对象。

#### 使用姿势

创建代理对象的细节已经被JDK隐藏，对于应用程序员来说就是调用一个静态方法即可：

```
// 方法签名
public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) {}

// 调用姿势1
InvocationHandler handler = new MyInvocationHandler(...);
Class proxyClass = Proxy.getProxyClass(
         Foo.class.getClassLoader(), new Class[] { Foo.class });
Foo f = (Foo) proxyClass.
         getConstructor(new Class[] { InvocationHandler.class }).
         newInstance(new Object[] { handler });
         
// 调用姿势2
InvocationHandler handler = new MyInvocationHandler(...);
Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),
                                          new Class[] { Foo.class },
                                          handler);
```



#### InvocationHandler

上面一步介绍了如何创建代理对象，代码非常简单，其核心是**MyInvocationHandler**，真实的增强逻辑需要编写在这个实现类中。

这样设计符合单一职责原则，Proxy只管动态生成代理类（具体来说就是动态生成一个Class对象放到JVM元空间中），而增强的逻辑被委派给InvocationHandler来实现，各自负责各自的职责。



* Spring框架实现的InvocationHandler--org.springframework.aop.framework.JdkDynamicAopProxy，这个InvocationHandler可以访问到原始目标对象target，最终代理给target来执行目标对象的方法。

  ```java
  // Spring利用JDK动态代理创建代理对象时，实现的InvocationHandler
  final class JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable {
    	/** Config used to configure this proxy */
      // 真实实现类为 org.springframework.aop.framework.ProxyFactory
  		private final AdvisedSupport advised;
  		
    	@Override
  		@Nullable
  		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
  			...
  		}
  }
  
  // targetSource实现类为 SingletonTargetSource，其中包含了目标对象target
  public class SingletonTargetSource implements TargetSource, Serializable {
  
  	/** use serialVersionUID from Spring 1.2 for interoperability */
  	private static final long serialVersionUID = 9031246629662423738L;
  
  
  	/** Target cached and invoked using reflection */
  	private final Object target;
  	
  	...
  	
  }
  
  // 最终通过反射来调用目标对象target的方法：
  // AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments);
  
    @Nullable
  	public static Object invokeJoinpointUsingReflection(@Nullable Object target, Method method, Object[] args)
  			throws Throwable {
  
  		// Use reflection to invoke the method.
  		try {
  			ReflectionUtils.makeAccessible(method);
  			return method.invoke(target, args);
  		}
  		catch (InvocationTargetException ex) {
  			// Invoked method threw a checked exception.
  			// We must rethrow it. The client won't see the interceptor.
  			throw ex.getTargetException();
  		}
  		catch (IllegalArgumentException ex) {
  			throw new AopInvocationException("AOP configuration seems to be invalid: tried calling method [" +
  					method + "] on target [" + target + "]", ex);
  		}
  		catch (IllegalAccessException ex) {
  			throw new AopInvocationException("Could not access method [" + method + "]", ex);
  		}
  	}
  
  
  ```

​		



![image-20210410183015412](/Users/taigai/Library/Application Support/typora-user-images/image-20210410183015412.png)



#### JDK动态代理底层原理

底层原理就在方法： java.lang.reflect.Proxy.ProxyClassFactory#apply()，底层使用sun.misc.ProxyGenerator#generateProxyClass()直接生成字节码：

```java
 private static final class ProxyClassFactory implements BiFunction<ClassLoader, Class<?>[], Class<?>>
 		// 动态生成代理类的核心方法
 		@Override
 		public Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {
    		Map<Class<?>, Boolean> interfaceSet = new IdentityHashMap<>(interfaces.length);
    		...
    		
    		// 代理类编号： private static final AtomicLong nextUniqueNumber = new AtomicLong();
    		long num = nextUniqueNumber.getAndIncrement();
    		
    		// 代理类名称： proxyName = "com.sun.proxy." + "$Proxy" + num
        String proxyName = proxyPkg + proxyClassNamePrefix + num;

        // 动态生成字节码二进制流
        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);
        
        // 动态生成类
        try {
            return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);
        } catch (ClassFormatError e) {
                /*
                 * A ClassFormatError here means that (barring bugs in the
                 * proxy class generation code) there was some other
                 * invalid aspect of the arguments supplied to the proxy
                 * class creation (such as virtual machine limitations
                 * exceeded).
                 */
                throw new IllegalArgumentException(e.toString());
        }
        ...
}
```



#### 代理类真面目

动态生成的代理类长什么样呢，可以通过反编译来看下

* 设置此环境变量，可以将动态生成的代理类写入本地文件

```
System.getProperties().setProperty("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");
```

* 反编译之后的Class

```java
package com.sun.proxy;

import cc.lzy.spring.aop.service.ICalculator;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.lang.reflect.UndeclaredThrowableException;
import org.aopalliance.aop.Advice;
import org.springframework.aop.Advisor;
import org.springframework.aop.SpringProxy;
import org.springframework.aop.TargetSource;
import org.springframework.aop.framework.Advised;
import org.springframework.aop.framework.AopConfigException;
import org.springframework.core.DecoratingProxy;

// SpringProxy, Advised, DecoratingProxy 这3个接口是Spring生成动态代理时默认增加的3个接口
// ICalculator是应用开发者自己的接口
public final class $Proxy14 extends Proxy implements ICalculator, SpringProxy, Advised, DecoratingProxy {
    private static Method m1;
    private static Method m19;
    private static Method m27;
    private static Method m12;
    private static Method m22;
    private static Method m17;
    private static Method m6;
    private static Method m11;
    private static Method m15;
    private static Method m14;
    private static Method m0;
    private static Method m18;
    private static Method m24;
    private static Method m26;
    private static Method m4;
    private static Method m9;
    private static Method m2;
    private static Method m28;
    private static Method m5;
    private static Method m20;
    private static Method m29;
    private static Method m21;
    private static Method m7;
    private static Method m8;
    private static Method m23;
    private static Method m13;
    private static Method m3;
    private static Method m25;
    private static Method m10;
    private static Method m16;

    public $Proxy14(InvocationHandler var1) throws  {
        super(var1);
    }

    public final boolean equals(Object var1) throws  {
        try {
            return (Boolean)super.h.invoke(this, m1, new Object[]{var1});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final void addAdvisor(Advisor var1) throws AopConfigException {
        try {
            super.h.invoke(this, m19, new Object[]{var1});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final boolean isExposeProxy() throws  {
        try {
            return (Boolean)super.h.invoke(this, m27, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final boolean isProxyTargetClass() throws  {
        try {
            return (Boolean)super.h.invoke(this, m12, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final void removeAdvisor(int var1) throws AopConfigException {
        try {
            super.h.invoke(this, m22, new Object[]{var1});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final Class[] getProxiedInterfaces() throws  {
        try {
            return (Class[])super.h.invoke(this, m17, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final int indexOf(Advisor var1) throws  {
        try {
            return (Integer)super.h.invoke(this, m6, new Object[]{var1});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final TargetSource getTargetSource() throws  {
        try {
            return (TargetSource)super.h.invoke(this, m11, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final void addAdvice(int var1, Advice var2) throws AopConfigException {
        try {
            super.h.invoke(this, m15, new Object[]{var1, var2});
        } catch (RuntimeException | Error var4) {
            throw var4;
        } catch (Throwable var5) {
            throw new UndeclaredThrowableException(var5);
        }
    }

    public final void addAdvice(Advice var1) throws AopConfigException {
        try {
            super.h.invoke(this, m14, new Object[]{var1});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final int hashCode() throws  {
        try {
            return (Integer)super.h.invoke(this, m0, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final boolean isInterfaceProxied(Class var1) throws  {
        try {
            return (Boolean)super.h.invoke(this, m18, new Object[]{var1});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final boolean removeAdvice(Advice var1) throws  {
        try {
            return (Boolean)super.h.invoke(this, m24, new Object[]{var1});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final void setExposeProxy(boolean var1) throws  {
        try {
            super.h.invoke(this, m26, new Object[]{var1});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final int divide(int var1, int var2) throws  {
        try {
            return (Integer)super.h.invoke(this, m4, new Object[]{var1, var2});
        } catch (RuntimeException | Error var4) {
            throw var4;
        } catch (Throwable var5) {
            throw new UndeclaredThrowableException(var5);
        }
    }

    public final void setTargetSource(TargetSource var1) throws  {
        try {
            super.h.invoke(this, m9, new Object[]{var1});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final String toString() throws  {
        try {
            return (String)super.h.invoke(this, m2, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final Class getTargetClass() throws  {
        try {
            return (Class)super.h.invoke(this, m28, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final int sub(int var1, int var2) throws  {
        try {
            return (Integer)super.h.invoke(this, m5, new Object[]{var1, var2});
        } catch (RuntimeException | Error var4) {
            throw var4;
        } catch (Throwable var5) {
            throw new UndeclaredThrowableException(var5);
        }
    }

    public final void addAdvisor(int var1, Advisor var2) throws AopConfigException {
        try {
            super.h.invoke(this, m20, new Object[]{var1, var2});
        } catch (RuntimeException | Error var4) {
            throw var4;
        } catch (Throwable var5) {
            throw new UndeclaredThrowableException(var5);
        }
    }

    public final Class getDecoratedClass() throws  {
        try {
            return (Class)super.h.invoke(this, m29, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final boolean removeAdvisor(Advisor var1) throws  {
        try {
            return (Boolean)super.h.invoke(this, m21, new Object[]{var1});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final int indexOf(Advice var1) throws  {
        try {
            return (Integer)super.h.invoke(this, m7, new Object[]{var1});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final boolean isFrozen() throws  {
        try {
            return (Boolean)super.h.invoke(this, m8, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final boolean replaceAdvisor(Advisor var1, Advisor var2) throws AopConfigException {
        try {
            return (Boolean)super.h.invoke(this, m23, new Object[]{var1, var2});
        } catch (RuntimeException | Error var4) {
            throw var4;
        } catch (Throwable var5) {
            throw new UndeclaredThrowableException(var5);
        }
    }

    public final void setPreFiltered(boolean var1) throws  {
        try {
            super.h.invoke(this, m13, new Object[]{var1});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final int add(int var1, int var2) throws  {
        try {
            return (Integer)super.h.invoke(this, m3, new Object[]{var1, var2});
        } catch (RuntimeException | Error var4) {
            throw var4;
        } catch (Throwable var5) {
            throw new UndeclaredThrowableException(var5);
        }
    }

    public final String toProxyConfigString() throws  {
        try {
            return (String)super.h.invoke(this, m25, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final Advisor[] getAdvisors() throws  {
        try {
            return (Advisor[])super.h.invoke(this, m10, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final boolean isPreFiltered() throws  {
        try {
            return (Boolean)super.h.invoke(this, m16, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    // m0、m1、m2固定为Object的hashCode、equals、toString 方法
    // 
    static {
        try {
            m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object"));
            m19 = Class.forName("org.springframework.aop.framework.Advised").getMethod("addAdvisor", Class.forName("org.springframework.aop.Advisor"));
            m27 = Class.forName("org.springframework.aop.framework.Advised").getMethod("isExposeProxy");
            m12 = Class.forName("org.springframework.aop.framework.Advised").getMethod("isProxyTargetClass");
            m22 = Class.forName("org.springframework.aop.framework.Advised").getMethod("removeAdvisor", Integer.TYPE);
            m17 = Class.forName("org.springframework.aop.framework.Advised").getMethod("getProxiedInterfaces");
            m6 = Class.forName("org.springframework.aop.framework.Advised").getMethod("indexOf", Class.forName("org.springframework.aop.Advisor"));
            m11 = Class.forName("org.springframework.aop.framework.Advised").getMethod("getTargetSource");
            m15 = Class.forName("org.springframework.aop.framework.Advised").getMethod("addAdvice", Integer.TYPE, Class.forName("org.aopalliance.aop.Advice"));
            m14 = Class.forName("org.springframework.aop.framework.Advised").getMethod("addAdvice", Class.forName("org.aopalliance.aop.Advice"));
            m0 = Class.forName("java.lang.Object").getMethod("hashCode");
            m18 = Class.forName("org.springframework.aop.framework.Advised").getMethod("isInterfaceProxied", Class.forName("java.lang.Class"));
            m24 = Class.forName("org.springframework.aop.framework.Advised").getMethod("removeAdvice", Class.forName("org.aopalliance.aop.Advice"));
            m26 = Class.forName("org.springframework.aop.framework.Advised").getMethod("setExposeProxy", Boolean.TYPE);
            m4 = Class.forName("cc.lzy.spring.aop.service.ICalculator").getMethod("divide", Integer.TYPE, Integer.TYPE);
            m9 = Class.forName("org.springframework.aop.framework.Advised").getMethod("setTargetSource", Class.forName("org.springframework.aop.TargetSource"));
            m2 = Class.forName("java.lang.Object").getMethod("toString");
            m28 = Class.forName("org.springframework.aop.framework.Advised").getMethod("getTargetClass");
            m5 = Class.forName("cc.lzy.spring.aop.service.ICalculator").getMethod("sub", Integer.TYPE, Integer.TYPE);
            m20 = Class.forName("org.springframework.aop.framework.Advised").getMethod("addAdvisor", Integer.TYPE, Class.forName("org.springframework.aop.Advisor"));
            m29 = Class.forName("org.springframework.core.DecoratingProxy").getMethod("getDecoratedClass");
            m21 = Class.forName("org.springframework.aop.framework.Advised").getMethod("removeAdvisor", Class.forName("org.springframework.aop.Advisor"));
            m7 = Class.forName("org.springframework.aop.framework.Advised").getMethod("indexOf", Class.forName("org.aopalliance.aop.Advice"));
            m8 = Class.forName("org.springframework.aop.framework.Advised").getMethod("isFrozen");
            m23 = Class.forName("org.springframework.aop.framework.Advised").getMethod("replaceAdvisor", Class.forName("org.springframework.aop.Advisor"), Class.forName("org.springframework.aop.Advisor"));
            m13 = Class.forName("org.springframework.aop.framework.Advised").getMethod("setPreFiltered", Boolean.TYPE);
            m3 = Class.forName("cc.lzy.spring.aop.service.ICalculator").getMethod("add", Integer.TYPE, Integer.TYPE);
            m25 = Class.forName("org.springframework.aop.framework.Advised").getMethod("toProxyConfigString");
            m10 = Class.forName("org.springframework.aop.framework.Advised").getMethod("getAdvisors");
            m16 = Class.forName("org.springframework.aop.framework.Advised").getMethod("isPreFiltered");
        } catch (NoSuchMethodException var2) {
            throw new NoSuchMethodError(var2.getMessage());
        } catch (ClassNotFoundException var3) {
            throw new NoClassDefFoundError(var3.getMessage());
        }
    }
}
```



### CGLIB代理

对于没有实现接口的类，无法利用JDK创建动态代理，此时Spring会利用CGLIB创建代理对象。

CGLIB通过继承目标对象的Class，成为其子类，然后通过在子类中覆写父类的方法，来执行代理逻辑，反编译后的Class。



```
 // 设置此参数，可以将动态生成的代理类写入本地文件，然后利用idea可以查看decompile之后的代码
 System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, ".//");
 
 ApplicationContext context = new ClassPathXmlApplicationContext("beans-aop-annotation-driven.xml");
 Object obj = context.getBean("itemService");

 // cc.lzy.spring.aop.service.ItemService@50caa560，代理给父类
 System.out.println(obj);

 // class cc.lzy.spring.aop.service.ItemService$$EnhancerBySpringCGLIB$$f91fab99 ，代理类，是个内部类，是外部类的子类，继承了外部类，子类可以覆盖父类的方法，从而可以执行代理逻辑
 System.out.println(obj.getClass());

 // class cc.lzy.spring.aop.service.ItemService
 System.out.println(obj.getClass().getSuperclass());
```



```
// 自定义的ItemService，没有实现接口
@Service
public class ItemService {
    public void addItem() {
        System.out.println("item adding...");
    }

    public void getItem(String itemId) {
        System.out.println("getting item..., itemId=" + itemId);
    }
}
```



```java
package cc.lzy.spring.aop.service;

import java.lang.reflect.Method;
import java.lang.reflect.UndeclaredThrowableException;
import org.aopalliance.aop.Advice;
import org.springframework.aop.Advisor;
import org.springframework.aop.SpringProxy;
import org.springframework.aop.TargetClassAware;
import org.springframework.aop.TargetSource;
import org.springframework.aop.framework.Advised;
import org.springframework.aop.framework.AopConfigException;
import org.springframework.cglib.core.ReflectUtils;
import org.springframework.cglib.core.Signature;
import org.springframework.cglib.proxy.Callback;
import org.springframework.cglib.proxy.Dispatcher;
import org.springframework.cglib.proxy.Factory;
import org.springframework.cglib.proxy.MethodInterceptor;
import org.springframework.cglib.proxy.MethodProxy;
import org.springframework.cglib.proxy.NoOp;

public class ItemService$$EnhancerBySpringCGLIB$$f91fab99 extends ItemService implements SpringProxy, Advised, Factory {
    private boolean CGLIB$BOUND;
    public static Object CGLIB$FACTORY_DATA;
    private static final ThreadLocal CGLIB$THREAD_CALLBACKS;
    private static final Callback[] CGLIB$STATIC_CALLBACKS;
    private MethodInterceptor CGLIB$CALLBACK_0;
    private MethodInterceptor CGLIB$CALLBACK_1;
    private NoOp CGLIB$CALLBACK_2;
    private Dispatcher CGLIB$CALLBACK_3;
    private Dispatcher CGLIB$CALLBACK_4;
    private MethodInterceptor CGLIB$CALLBACK_5;
    private MethodInterceptor CGLIB$CALLBACK_6;
    private static Object CGLIB$CALLBACK_FILTER;
    private static final Method CGLIB$addItem$0$Method;
    private static final MethodProxy CGLIB$addItem$0$Proxy;
    private static final Object[] CGLIB$emptyArgs;
    private static final Method CGLIB$getItem$1$Method;
    private static final MethodProxy CGLIB$getItem$1$Proxy;
    private static final Method CGLIB$equals$2$Method;
    private static final MethodProxy CGLIB$equals$2$Proxy;
    private static final Method CGLIB$toString$3$Method;
    private static final MethodProxy CGLIB$toString$3$Proxy;
    private static final Method CGLIB$hashCode$4$Method;
    private static final MethodProxy CGLIB$hashCode$4$Proxy;
    private static final Method CGLIB$clone$5$Method;
    private static final MethodProxy CGLIB$clone$5$Proxy;

    static void CGLIB$STATICHOOK1() {
        CGLIB$THREAD_CALLBACKS = new ThreadLocal();
        CGLIB$emptyArgs = new Object[0];
        Class var0 = Class.forName("cc.lzy.spring.aop.service.ItemService$$EnhancerBySpringCGLIB$$f91fab99");
        Class var1;
        Method[] var10000 = ReflectUtils.findMethods(new String[]{"equals", "(Ljava/lang/Object;)Z", "toString", "()Ljava/lang/String;", "hashCode", "()I", "clone", "()Ljava/lang/Object;"}, (var1 = Class.forName("java.lang.Object")).getDeclaredMethods());
        CGLIB$equals$2$Method = var10000[0];
        CGLIB$equals$2$Proxy = MethodProxy.create(var1, var0, "(Ljava/lang/Object;)Z", "equals", "CGLIB$equals$2");
        CGLIB$toString$3$Method = var10000[1];
        CGLIB$toString$3$Proxy = MethodProxy.create(var1, var0, "()Ljava/lang/String;", "toString", "CGLIB$toString$3");
        CGLIB$hashCode$4$Method = var10000[2];
        CGLIB$hashCode$4$Proxy = MethodProxy.create(var1, var0, "()I", "hashCode", "CGLIB$hashCode$4");
        CGLIB$clone$5$Method = var10000[3];
        CGLIB$clone$5$Proxy = MethodProxy.create(var1, var0, "()Ljava/lang/Object;", "clone", "CGLIB$clone$5");
        var10000 = ReflectUtils.findMethods(new String[]{"addItem", "()V", "getItem", "(Ljava/lang/String;)V"}, (var1 = Class.forName("cc.lzy.spring.aop.service.ItemService")).getDeclaredMethods());
        CGLIB$addItem$0$Method = var10000[0];
        CGLIB$addItem$0$Proxy = MethodProxy.create(var1, var0, "()V", "addItem", "CGLIB$addItem$0");
        CGLIB$getItem$1$Method = var10000[1];
        CGLIB$getItem$1$Proxy = MethodProxy.create(var1, var0, "(Ljava/lang/String;)V", "getItem", "CGLIB$getItem$1");
    }

    final void CGLIB$addItem$0() {
        super.addItem();
    }

    public final void addItem() {
        try {
            MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_0;
            }

            if (var10000 != null) {
                var10000.intercept(this, CGLIB$addItem$0$Method, CGLIB$emptyArgs, CGLIB$addItem$0$Proxy);
            } else {
                super.addItem();
            }
        } catch (Error | RuntimeException var1) {
            throw var1;
        } catch (Throwable var2) {
            throw new UndeclaredThrowableException(var2);
        }
    }

    final void CGLIB$getItem$1(String var1) {
        super.getItem(var1);
    }

    public final void getItem(String var1) {
        try {
            MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_0;
            }

            if (var10000 != null) {
                var10000.intercept(this, CGLIB$getItem$1$Method, new Object[]{var1}, CGLIB$getItem$1$Proxy);
            } else {
                super.getItem(var1);
            }
        } catch (Error | RuntimeException var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    final boolean CGLIB$equals$2(Object var1) {
        return super.equals(var1);
    }

    public final boolean equals(Object var1) {
        try {
            MethodInterceptor var10000 = this.CGLIB$CALLBACK_5;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_5;
            }

            if (var10000 != null) {
                Object var4 = var10000.intercept(this, CGLIB$equals$2$Method, new Object[]{var1}, CGLIB$equals$2$Proxy);
                return var4 == null ? false : (Boolean)var4;
            } else {
                return super.equals(var1);
            }
        } catch (Error | RuntimeException var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    final String CGLIB$toString$3() {
        return super.toString();
    }

    public final String toString() {
        try {
            MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_0;
            }

            return var10000 != null ? (String)var10000.intercept(this, CGLIB$toString$3$Method, CGLIB$emptyArgs, CGLIB$toString$3$Proxy) : super.toString();
        } catch (Error | RuntimeException var1) {
            throw var1;
        } catch (Throwable var2) {
            throw new UndeclaredThrowableException(var2);
        }
    }

    final int CGLIB$hashCode$4() {
        return super.hashCode();
    }

    public final int hashCode() {
        try {
            MethodInterceptor var10000 = this.CGLIB$CALLBACK_6;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_6;
            }

            if (var10000 != null) {
                Object var3 = var10000.intercept(this, CGLIB$hashCode$4$Method, CGLIB$emptyArgs, CGLIB$hashCode$4$Proxy);
                return var3 == null ? 0 : ((Number)var3).intValue();
            } else {
                return super.hashCode();
            }
        } catch (Error | RuntimeException var1) {
            throw var1;
        } catch (Throwable var2) {
            throw new UndeclaredThrowableException(var2);
        }
    }

    final Object CGLIB$clone$5() throws CloneNotSupportedException {
        return super.clone();
    }

    protected final Object clone() throws CloneNotSupportedException {
        try {
            MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_0;
            }

            return var10000 != null ? var10000.intercept(this, CGLIB$clone$5$Method, CGLIB$emptyArgs, CGLIB$clone$5$Proxy) : super.clone();
        } catch (Error | CloneNotSupportedException | RuntimeException var1) {
            throw var1;
        } catch (Throwable var2) {
            throw new UndeclaredThrowableException(var2);
        }
    }

    public static MethodProxy CGLIB$findMethodProxy(Signature var0) {
        String var10000 = var0.toString();
        switch(var10000.hashCode()) {
        case -508378822:
            if (var10000.equals("clone()Ljava/lang/Object;")) {
                return CGLIB$clone$5$Proxy;
            }
            break;
        case -270582879:
            if (var10000.equals("addItem()V")) {
                return CGLIB$addItem$0$Proxy;
            }
            break;
        case 1826985398:
            if (var10000.equals("equals(Ljava/lang/Object;)Z")) {
                return CGLIB$equals$2$Proxy;
            }
            break;
        case 1902087702:
            if (var10000.equals("getItem(Ljava/lang/String;)V")) {
                return CGLIB$getItem$1$Proxy;
            }
            break;
        case 1913648695:
            if (var10000.equals("toString()Ljava/lang/String;")) {
                return CGLIB$toString$3$Proxy;
            }
            break;
        case 1984935277:
            if (var10000.equals("hashCode()I")) {
                return CGLIB$hashCode$4$Proxy;
            }
        }

        return null;
    }

    public final int indexOf(Advisor var1) {
        try {
            Dispatcher var10000 = this.CGLIB$CALLBACK_4;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_4;
            }

            return ((Advised)var10000.loadObject()).indexOf(var1);
        } catch (Error | RuntimeException var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final int indexOf(Advice var1) {
        try {
            Dispatcher var10000 = this.CGLIB$CALLBACK_4;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_4;
            }

            return ((Advised)var10000.loadObject()).indexOf(var1);
        } catch (Error | RuntimeException var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final boolean isFrozen() {
        try {
            Dispatcher var10000 = this.CGLIB$CALLBACK_4;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_4;
            }

            return ((Advised)var10000.loadObject()).isFrozen();
        } catch (Error | RuntimeException var1) {
            throw var1;
        } catch (Throwable var2) {
            throw new UndeclaredThrowableException(var2);
        }
    }

    public final void addAdvice(Advice var1) throws AopConfigException {
        try {
            Dispatcher var10000 = this.CGLIB$CALLBACK_4;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_4;
            }

            ((Advised)var10000.loadObject()).addAdvice(var1);
        } catch (Error | AopConfigException | RuntimeException var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final void addAdvice(int var1, Advice var2) throws AopConfigException {
        try {
            Dispatcher var10000 = this.CGLIB$CALLBACK_4;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_4;
            }

            ((Advised)var10000.loadObject()).addAdvice(var1, var2);
        } catch (Error | AopConfigException | RuntimeException var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final boolean isPreFiltered() {
        try {
            Dispatcher var10000 = this.CGLIB$CALLBACK_4;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_4;
            }

            return ((Advised)var10000.loadObject()).isPreFiltered();
        } catch (Error | RuntimeException var1) {
            throw var1;
        } catch (Throwable var2) {
            throw new UndeclaredThrowableException(var2);
        }
    }

    public final Class[] getProxiedInterfaces() {
        try {
            Dispatcher var10000 = this.CGLIB$CALLBACK_4;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_4;
            }

            return ((Advised)var10000.loadObject()).getProxiedInterfaces();
        } catch (Error | RuntimeException var1) {
            throw var1;
        } catch (Throwable var2) {
            throw new UndeclaredThrowableException(var2);
        }
    }

    public final boolean isInterfaceProxied(Class var1) {
        try {
            Dispatcher var10000 = this.CGLIB$CALLBACK_4;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_4;
            }

            return ((Advised)var10000.loadObject()).isInterfaceProxied(var1);
        } catch (Error | RuntimeException var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final void addAdvisor(Advisor var1) throws AopConfigException {
        try {
            Dispatcher var10000 = this.CGLIB$CALLBACK_4;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_4;
            }

            ((Advised)var10000.loadObject()).addAdvisor(var1);
        } catch (Error | AopConfigException | RuntimeException var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final void addAdvisor(int var1, Advisor var2) throws AopConfigException {
        try {
            Dispatcher var10000 = this.CGLIB$CALLBACK_4;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_4;
            }

            ((Advised)var10000.loadObject()).addAdvisor(var1, var2);
        } catch (Error | AopConfigException | RuntimeException var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final void removeAdvisor(int var1) throws AopConfigException {
        try {
            Dispatcher var10000 = this.CGLIB$CALLBACK_4;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_4;
            }

            ((Advised)var10000.loadObject()).removeAdvisor(var1);
        } catch (Error | AopConfigException | RuntimeException var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final boolean removeAdvisor(Advisor var1) {
        try {
            Dispatcher var10000 = this.CGLIB$CALLBACK_4;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_4;
            }

            return ((Advised)var10000.loadObject()).removeAdvisor(var1);
        } catch (Error | RuntimeException var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final boolean replaceAdvisor(Advisor var1, Advisor var2) throws AopConfigException {
        try {
            Dispatcher var10000 = this.CGLIB$CALLBACK_4;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_4;
            }

            return ((Advised)var10000.loadObject()).replaceAdvisor(var1, var2);
        } catch (Error | AopConfigException | RuntimeException var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final boolean removeAdvice(Advice var1) {
        try {
            Dispatcher var10000 = this.CGLIB$CALLBACK_4;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_4;
            }

            return ((Advised)var10000.loadObject()).removeAdvice(var1);
        } catch (Error | RuntimeException var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final String toProxyConfigString() {
        try {
            Dispatcher var10000 = this.CGLIB$CALLBACK_4;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_4;
            }

            return ((Advised)var10000.loadObject()).toProxyConfigString();
        } catch (Error | RuntimeException var1) {
            throw var1;
        } catch (Throwable var2) {
            throw new UndeclaredThrowableException(var2);
        }
    }

    public final void setTargetSource(TargetSource var1) {
        try {
            Dispatcher var10000 = this.CGLIB$CALLBACK_4;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_4;
            }

            ((Advised)var10000.loadObject()).setTargetSource(var1);
        } catch (Error | RuntimeException var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final TargetSource getTargetSource() {
        try {
            Dispatcher var10000 = this.CGLIB$CALLBACK_4;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_4;
            }

            return ((Advised)var10000.loadObject()).getTargetSource();
        } catch (Error | RuntimeException var1) {
            throw var1;
        } catch (Throwable var2) {
            throw new UndeclaredThrowableException(var2);
        }
    }

    public final boolean isProxyTargetClass() {
        try {
            Dispatcher var10000 = this.CGLIB$CALLBACK_4;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_4;
            }

            return ((Advised)var10000.loadObject()).isProxyTargetClass();
        } catch (Error | RuntimeException var1) {
            throw var1;
        } catch (Throwable var2) {
            throw new UndeclaredThrowableException(var2);
        }
    }

    public final void setPreFiltered(boolean var1) {
        try {
            Dispatcher var10000 = this.CGLIB$CALLBACK_4;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_4;
            }

            ((Advised)var10000.loadObject()).setPreFiltered(var1);
        } catch (Error | RuntimeException var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final void setExposeProxy(boolean var1) {
        try {
            Dispatcher var10000 = this.CGLIB$CALLBACK_4;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_4;
            }

            ((Advised)var10000.loadObject()).setExposeProxy(var1);
        } catch (Error | RuntimeException var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final boolean isExposeProxy() {
        try {
            Dispatcher var10000 = this.CGLIB$CALLBACK_4;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_4;
            }

            return ((Advised)var10000.loadObject()).isExposeProxy();
        } catch (Error | RuntimeException var1) {
            throw var1;
        } catch (Throwable var2) {
            throw new UndeclaredThrowableException(var2);
        }
    }

    public final Advisor[] getAdvisors() {
        try {
            Dispatcher var10000 = this.CGLIB$CALLBACK_4;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_4;
            }

            return ((Advised)var10000.loadObject()).getAdvisors();
        } catch (Error | RuntimeException var1) {
            throw var1;
        } catch (Throwable var2) {
            throw new UndeclaredThrowableException(var2);
        }
    }

    public final Class getTargetClass() {
        try {
            Dispatcher var10000 = this.CGLIB$CALLBACK_4;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_4;
            }

            return ((TargetClassAware)var10000.loadObject()).getTargetClass();
        } catch (Error | RuntimeException var1) {
            throw var1;
        } catch (Throwable var2) {
            throw new UndeclaredThrowableException(var2);
        }
    }

    public ItemService$$EnhancerBySpringCGLIB$$f91fab99() {
        try {
            super();
            CGLIB$BIND_CALLBACKS(this);
        } catch (Error | RuntimeException var1) {
            throw var1;
        } catch (Throwable var2) {
            throw new UndeclaredThrowableException(var2);
        }
    }

    public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) {
        CGLIB$THREAD_CALLBACKS.set(var0);
    }

    public static void CGLIB$SET_STATIC_CALLBACKS(Callback[] var0) {
        CGLIB$STATIC_CALLBACKS = var0;
    }

    private static final void CGLIB$BIND_CALLBACKS(Object var0) {
        ItemService$$EnhancerBySpringCGLIB$$f91fab99 var1 = (ItemService$$EnhancerBySpringCGLIB$$f91fab99)var0;
        if (!var1.CGLIB$BOUND) {
            var1.CGLIB$BOUND = true;
            Object var10000 = CGLIB$THREAD_CALLBACKS.get();
            if (var10000 == null) {
                var10000 = CGLIB$STATIC_CALLBACKS;
                if (var10000 == null) {
                    return;
                }
            }

            Callback[] var10001 = (Callback[])var10000;
            var1.CGLIB$CALLBACK_6 = (MethodInterceptor)((Callback[])var10000)[6];
            var1.CGLIB$CALLBACK_5 = (MethodInterceptor)var10001[5];
            var1.CGLIB$CALLBACK_4 = (Dispatcher)var10001[4];
            var1.CGLIB$CALLBACK_3 = (Dispatcher)var10001[3];
            var1.CGLIB$CALLBACK_2 = (NoOp)var10001[2];
            var1.CGLIB$CALLBACK_1 = (MethodInterceptor)var10001[1];
            var1.CGLIB$CALLBACK_0 = (MethodInterceptor)var10001[0];
        }

    }

    public Object newInstance(Callback[] var1) {
        try {
            CGLIB$SET_THREAD_CALLBACKS(var1);
            ItemService$$EnhancerBySpringCGLIB$$f91fab99 var10000 = new ItemService$$EnhancerBySpringCGLIB$$f91fab99();
            CGLIB$SET_THREAD_CALLBACKS((Callback[])null);
            return var10000;
        } catch (Error | RuntimeException var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public Object newInstance(Callback var1) {
        try {
            throw new IllegalStateException("More than one callback object required");
        } catch (Error | RuntimeException var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public Object newInstance(Class[] var1, Object[] var2, Callback[] var3) {
        try {
            CGLIB$SET_THREAD_CALLBACKS(var3);
            ItemService$$EnhancerBySpringCGLIB$$f91fab99 var10000 = new ItemService$$EnhancerBySpringCGLIB$$f91fab99;
            switch(var1.length) {
            case 0:
                var10000.<init>();
                CGLIB$SET_THREAD_CALLBACKS((Callback[])null);
                return var10000;
            default:
                throw new IllegalArgumentException("Constructor not found");
            }
        } catch (Error | RuntimeException var4) {
            throw var4;
        } catch (Throwable var5) {
            throw new UndeclaredThrowableException(var5);
        }
    }

    public Callback getCallback(int var1) {
        try {
            CGLIB$BIND_CALLBACKS(this);
            Object var10000;
            switch(var1) {
            case 0:
                var10000 = this.CGLIB$CALLBACK_0;
                break;
            case 1:
                var10000 = this.CGLIB$CALLBACK_1;
                break;
            case 2:
                var10000 = this.CGLIB$CALLBACK_2;
                break;
            case 3:
                var10000 = this.CGLIB$CALLBACK_3;
                break;
            case 4:
                var10000 = this.CGLIB$CALLBACK_4;
                break;
            case 5:
                var10000 = this.CGLIB$CALLBACK_5;
                break;
            case 6:
                var10000 = this.CGLIB$CALLBACK_6;
                break;
            default:
                var10000 = null;
            }

            return (Callback)var10000;
        } catch (Error | RuntimeException var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public void setCallback(int var1, Callback var2) {
        try {
            switch(var1) {
            case 0:
                this.CGLIB$CALLBACK_0 = (MethodInterceptor)var2;
                break;
            case 1:
                this.CGLIB$CALLBACK_1 = (MethodInterceptor)var2;
                break;
            case 2:
                this.CGLIB$CALLBACK_2 = (NoOp)var2;
                break;
            case 3:
                this.CGLIB$CALLBACK_3 = (Dispatcher)var2;
                break;
            case 4:
                this.CGLIB$CALLBACK_4 = (Dispatcher)var2;
                break;
            case 5:
                this.CGLIB$CALLBACK_5 = (MethodInterceptor)var2;
                break;
            case 6:
                this.CGLIB$CALLBACK_6 = (MethodInterceptor)var2;
            }

        } catch (Error | RuntimeException var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public Callback[] getCallbacks() {
        try {
            CGLIB$BIND_CALLBACKS(this);
            return new Callback[]{this.CGLIB$CALLBACK_0, this.CGLIB$CALLBACK_1, this.CGLIB$CALLBACK_2, this.CGLIB$CALLBACK_3, this.CGLIB$CALLBACK_4, this.CGLIB$CALLBACK_5, this.CGLIB$CALLBACK_6};
        } catch (Error | RuntimeException var1) {
            throw var1;
        } catch (Throwable var2) {
            throw new UndeclaredThrowableException(var2);
        }
    }

    public void setCallbacks(Callback[] var1) {
        try {
            this.CGLIB$CALLBACK_0 = (MethodInterceptor)var1[0];
            this.CGLIB$CALLBACK_1 = (MethodInterceptor)var1[1];
            this.CGLIB$CALLBACK_2 = (NoOp)var1[2];
            this.CGLIB$CALLBACK_3 = (Dispatcher)var1[3];
            this.CGLIB$CALLBACK_4 = (Dispatcher)var1[4];
            this.CGLIB$CALLBACK_5 = (MethodInterceptor)var1[5];
            this.CGLIB$CALLBACK_6 = (MethodInterceptor)var1[6];
        } catch (Error | RuntimeException var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    static {
        CGLIB$STATICHOOK2();
        CGLIB$STATICHOOK1();
    }

    static void CGLIB$STATICHOOK2() {
        try {
            ;
        } catch (Error | RuntimeException var0) {
            throw var0;
        } catch (Throwable var1) {
            throw new UndeclaredThrowableException(var1);
        }
    }
}

```

